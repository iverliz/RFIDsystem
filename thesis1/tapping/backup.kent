import sys, time, os, csv, subprocess, serial
from datetime import datetime, timedelta
import mysql.connector

from PyQt5.QtMultimedia import QSoundEffect
from PyQt5.QtCore import QUrl

from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt5.QtGui import QPixmap, QFont
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QPushButton,
    QVBoxLayout, QHBoxLayout, QFrame, QSizePolicy
)

# ---------------- PATHS ----------------
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DEFAULT_PHOTO = os.path.join(BASE_DIR, "..", "assets", "default_photo.jfif")
HISTORY_DIR = os.path.join(BASE_DIR, "history log")

SOUND_DIR = os.path.join(BASE_DIR, "sound effect")

AUTHORIZED_SOUND = os.path.join(SOUND_DIR, "authorized_sound.wav")
DENIED_SOUND = os.path.join(SOUND_DIR, "denied_sound.wav")

# ---------------- SERIAL THREAD ----------------
class SerialThread(QThread):
    uid_scanned = pyqtSignal(str)

    def __init__(self, port="COM4", baud=9600):
        super().__init__()
        self.port = port
        self.baud = baud
        self.ser = None
        
    def run(self):
        try:
            self.ser = serial.Serial(self.port, self.baud, timeout=1)
            time.sleep(2)
            while self.isRunning():
                if self.ser.in_waiting:
                    uid = self.ser.readline().decode(errors="ignore").strip()
                    clean_uid = uid.split(":")[-1].strip()
                    self.uid_scanned.emit(clean_uid)
        except Exception as e:
            print("Serial error:", e)

    def write(self, message):
        if self.ser and self.ser.is_open:
            self.ser.write((message + "\n").encode())

    # ---------------- STOP ----------------
    def stop(self):
        if self.ser and self.ser.is_open:
            self.ser.close()
    

# ---------------- MAIN WINDOW ----------------
class RFIDTapping(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("RFID Fetcher - Student System")
        self.setGeometry(100, 100, 1300, 800)

        # ---------------- DATABASE ----------------
        self.db = mysql.connector.connect(
            host="localhost",
            user="root",
            password="123456",
            database="rfid_system"
        )
        self.cursor = self.db.cursor(dictionary=True)

        # ---------------- STATE ----------------
        self.active_fetcher = None
        self.fetcher_students = []
        self.fetched_students = set()
        self.pending_student = None
        self.completed_fetchers = set()

        self.active_teacher = None
        self.teacher_timer = QTimer(singleShot=True)
        self.teacher_timer.timeout.connect(self.reset_teacher_mode)

        self.globally_fetched_students = set()

        self.student_fetched_by = {}

        self.last_paired_type = None   # "FETCHER" or "TEACHER"
        self.last_paired_data = None   # fetcher or teacher row


        self.replay_mode = False

        

        
        self.holding = {}

        # ---------------- HISTORY ----------------
        os.makedirs(HISTORY_DIR, exist_ok=True)
        self.history_file = os.path.join(
            HISTORY_DIR, f"history_{datetime.now():%Y-%m-%d}.csv"
        )
        if not os.path.exists(self.history_file):
            with open(self.history_file, "w", newline="", encoding="utf-8") as f:
                csv.writer(f).writerow(
                    ["Date", "Time", "Fetcher", "Student", "Status"]
                )

        # ---------------- UI ----------------
        self.init_ui()

        # ---------------- TIMERS ----------------
        self.fetcher_timer = QTimer(singleShot=True)
        self.fetcher_timer.timeout.connect(self.move_fetcher_to_holding)

        self.student_display_timer = QTimer(singleShot=True)
        self.student_display_timer.timeout.connect(self.reset_student_panel)

        self.student_wait_timer = QTimer(singleShot=True)
        self.student_wait_timer.timeout.connect(self.student_wait_timeout)

        self.clock_timer = QTimer()
        self.clock_timer.timeout.connect(self.update_clock)
        self.clock_timer.start(1000)

        self.holding_cleanup = QTimer()
        self.holding_cleanup.timeout.connect(self.cleanup_holding)
        self.holding_cleanup.start(60000)

        # ---------------- SERIAL ----------------
        self.serial = SerialThread()
        self.serial.uid_scanned.connect(self.process_rfid)
        self.serial.start()

        # üîä SOUND EFFECTS (ADD THIS BLOCK)
        self.sound_authorized = QSoundEffect()
        self.sound_authorized.setSource(QUrl.fromLocalFile(AUTHORIZED_SOUND))
        self.sound_authorized.setVolume(0.9)

        self.sound_denied = QSoundEffect()
        self.sound_denied.setSource(QUrl.fromLocalFile(DENIED_SOUND))
        self.sound_denied.setVolume(0.9)

        self.reset_all()

    # ---------------- UI (UNCHANGED) ----------------
    def init_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        main = QHBoxLayout(central)

        self.fetcher_panel = self.create_panel("FETCHER", "#1e3a8a")
        self.student_panel = self.create_panel("STUDENT", "#047857")

        left = QHBoxLayout()
        left.addWidget(self.fetcher_panel)
        left.addWidget(self.student_panel)

        right = QVBoxLayout()

        self.title = QLabel("RFID Fetcher - Student System", alignment=Qt.AlignCenter)
        self.title.setFont(QFont("Segoe UI", 18, QFont.Bold))
        self.title.setStyleSheet("""
                        QLabel {
                            color: white;
                            padding: 12px;
                            font-weight: bold;
                            text-shadow: 1px 1px 2px rgba(0,0,0,120);
                            background: qlineargradient(
                                x1:0, y1:0,
                                x2:1, y2:0,
                                stop:0 #2563eb,   /* blue */
                                stop:1 #eab308    /* slightly darker yellow */
                            );
                        }
                    """)

        # ---- DATE & TIME BOX ----
        self.datetime_frame = QFrame()
        self.datetime_frame.setStyleSheet(
            "background:#d4d4d8;border-radius:10px;padding:3px;"
        )

        dt_layout = QVBoxLayout(self.datetime_frame)
        dt_layout.setSpacing(2)

        self.date_label = QLabel(alignment=Qt.AlignCenter)
        self.time_label = QLabel(alignment=Qt.AlignCenter)

        self.date_label.setFont(QFont("Segoe UI", 12))
        self.time_label.setFont(QFont("Segoe UI", 16, QFont.Bold))

        dt_layout.addWidget(self.date_label)
        dt_layout.addWidget(self.time_label)

        self.status = QLabel("WAITING FOR RFID...", alignment=Qt.AlignCenter)
        self.status.setFont(QFont("Segoe UI", 14, QFont.Bold))
        self.status.setStyleSheet("background:#6b7280;color:white;padding:10px;")

        self.open_btn = QPushButton("üìÇ Open History File")
        self.open_btn.clicked.connect(
            lambda: subprocess.Popen(["explorer", os.path.abspath(self.history_file)])
        )

        self.holding_layout = QVBoxLayout()
        self.spacer = QFrame()
        self.spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        for w in (
            self.title, self.datetime_frame,
            self.status, self.open_btn
        ):
            right.addWidget(w)

        right.addLayout(self.holding_layout)
        right.addWidget(self.spacer)

        main.addLayout(left, 2)
        main.addLayout(right, 1)

    def create_panel(self, title, color):
        frame = QFrame()
        layout = QVBoxLayout(frame)

        lbl = QLabel(title, alignment=Qt.AlignCenter)
        lbl.setFont(QFont("Segoe UI", 25, QFont.Bold))
        lbl.setStyleSheet(f"background:{color};color:white;padding:8px;")

        img = QLabel(alignment=Qt.AlignCenter)
        name = QLabel("WAITING", alignment=Qt.AlignCenter)
        name.setFont(QFont("Segoe UI", 17, QFont.Bold))

        info = QLabel("", alignment=Qt.AlignCenter)
        info.setWordWrap(True)
        info.setFont(QFont("Segoe UI", 14))

        for w in (lbl, img, name, info):
            layout.addWidget(w)

        frame.title_label = lbl

        frame.image, frame.name, frame.info = img, name, info
        return frame

    # ---------------- PHOTO ----------------
    def load_photo(self, path):
        pix = QPixmap(path) if path and os.path.exists(path) else QPixmap()
        if pix.isNull():
            pix = QPixmap(DEFAULT_PHOTO)
        return pix.scaled(150, 150, Qt.KeepAspectRatio, Qt.SmoothTransformation)

    # ---------------- RFID ----------------
    def process_rfid(self, uid):
        self.cursor.execute("SELECT * FROM student WHERE Student_id=%s", (uid,))
        student = self.cursor.fetchone()

        if student:
            self.cursor.execute(
                "SELECT rfid FROM registrations WHERE student_id=%s",
                (student["Student_id"],)
            )
            row = self.cursor.fetchone()

            if row and row["rfid"] in self.completed_fetchers:
                self.show_temp_status(
                    "STUDENT ALREADY FETCHED - FETCHER COMPLETED",
                    bg="#334155",
                    fg="white"
                
                )
                return
            
        # üîí GLOBAL BLOCK: STUDENT ALREADY FETCHED (FETCHER OR TEACHER)
        if student and student["Student_id"] in self.globally_fetched_students:

            # Show student info again
            self.student_panel.image.setPixmap(
                self.load_photo(student.get("photo_path"))
            )
            self.student_panel.name.setText(student["Student_name"])
            self.student_panel.info.setText(
                f"ID: {student['Student_id']}\n"
                f"Grade: {student['grade_lvl']}\n"
                f"Teacher: {student['Teacher_name']}"
            )

            person_type, data = self.student_fetched_by.get(
                student["Student_id"], (None, None)
            )

            if person_type == "TEACHER":
                self.show_paired_by("TEACHER", data)

            elif person_type == "FETCHER":
                self.show_fetcher_from_holding_temporarily(student["Student_id"])

            self.status.setText("STUDENT HAS ALREADY BEEN FETCHED")
            

            self.status.setStyleSheet(
                "background:#f59e0b;color:black;padding:10px;"
            )

            # ‚è± AUTO HIDE STUDENT AFTER 5 SECONDS
            self.replay_mode = True

            QTimer.singleShot(4000, self.end_replay_mode)

            return
        

        if student and self.active_fetcher is None:
            for rfid, h in self.holding.items():
                if student["Student_id"] in h["student_ids"]:
                    self.student_wait_timer.stop()
                    self.activate_fetcher_from_holding(rfid, student)
                    return


        # ---------- TEACHER RFID CHECK ----------
               
        self.cursor.execute(
            "SELECT * FROM teacher WHERE rfid = %s",
            (uid,)
        )
        teacher = self.cursor.fetchone()

        if teacher:
            self.activate_teacher(teacher)
            return



        self.cursor.execute("SELECT * FROM fetcher WHERE rfid=%s", (uid,))
        fetcher = self.cursor.fetchone()

        # üö´ BLOCK FETCHER IF ALL STUDENTS ALREADY FETCHED (TEACHER OVERRIDE CASE)
        if fetcher:
            students = self.get_students(fetcher["rfid"])
            fetched_count = sum(
                1 for s in students
                if s["Student_id"] in self.globally_fetched_students
            )

            if students and fetched_count == len(students):
                self.completed_fetchers.add(fetcher["rfid"])
                self.show_temp_status(
                    "FETCHER HAS COMPLETED ALL STUDENTS",
                    bg="#334155",
                    fg="white"
                )
                return


        if fetcher and fetcher["rfid"] in self.completed_fetchers:
            self.show_temp_status(
                "FETCHER HAS COMPLETED ALL STUDENTS",
                bg="#334155",
                fg="white"
            )
            return

        if fetcher:
            self.student_wait_timer.stop()

            # ‚úÖ NEW: Fetcher already in holding ‚Üí no duplicate
            if fetcher["rfid"] in self.holding and not self.active_fetcher:
                self.show_temp_status(
                    "FETCHER IS ALREADY IN HOLDING QUEUE"
                )
                return

            self.activate_fetcher(fetcher)
            return

        if student:
            self.handle_student(student)
            

    # ---------------- STUDENT FIRST ----------------
    def handle_student(self, student):

        if self.active_teacher:

            self.student_panel.image.setPixmap(
            self.load_photo(student.get("photo_path"))
            )
            self.student_panel.name.setText(student["Student_name"])
            self.student_panel.info.setText(
                f"ID: {student['Student_id']}\n"
                f"Grade: {student['grade_lvl']}\n"
                f"Teacher: {student['Teacher_name']}"
            )

            self.try_pair(student)
            return

        if not self.active_fetcher:
            self.pending_student = student

            self.student_panel.image.setPixmap(self.load_photo(student.get("photo_path")))
            self.student_panel.name.setText(student["Student_name"])
            self.student_panel.info.setText(
                f"ID: {student['Student_id']}\n"
                f"Grade: {student['grade_lvl']}\n"
                f"Teacher: {student['Teacher_name']}"
            )

            self.status.setText("STUDENT SCANNED ‚Äì WAITING FOR FETCHER")

            # ‚è± 7-second waiting window
            self.student_wait_timer.start(7000)
            return

        self.try_pair(student)

    def student_wait_timeout(self):
        self.pending_student = None
        self.reset_student_panel()
        self.status.setText("WAITING FOR RFID...")
        self.status.setStyleSheet("background:#6b7280;color:white;padding:10px;")

    # ---------------- FETCHER ----------------
    def activate_fetcher(self, fetcher):
        if self.active_fetcher:
            return

        self.active_fetcher = fetcher
        self.fetcher_students = self.get_students(fetcher["rfid"])
        self.fetched_students = set()

        # üîë SYNC teacher overrides ‚Üí fetcher state
        self.sync_fetched_from_global()

        self.check_and_mark_fetcher_completed()

        self.fetcher_panel.image.setPixmap(self.load_photo(fetcher.get("photo_path")))
        self.fetcher_panel.name.setText(fetcher["Fetcher_name"])
        self.update_fetcher_student_list()

        self.status.setText("FETCHER READY ‚Äì WAITING FOR STUDENT")

        if self.pending_student:
            student = self.pending_student
            self.pending_student = None
            self.try_pair(student)
            return

        self.fetcher_timer.start(10000)


    def activate_teacher(self, teacher):
        # Override fetcher
        self.active_teacher = teacher
        self.active_fetcher = None

        self.fetcher_panel.title_label.setText("TEACHER")

        # Display teacher in FETCHER panel
        self.fetcher_panel.image.setPixmap(
            self.load_photo(teacher.get("photo_path"))
        )
        self.fetcher_panel.name.setText( f"TEACHER ({teacher['Teacher_name']})")
        self.fetcher_panel.info.setText(
            f"Name: {teacher['Teacher_name']}\n"
            f"Grade: {teacher['Teacher_grade']}"
        )

        self.status.setText("TEACHER MODE ‚Äì WAITING FOR STUDENT")
        self.status.setStyleSheet(
            "background:#0f766e;color:white;padding:10px;"
        )

        # Teacher auto-exit after 15 seconds
        self.teacher_timer.start(10000)

        if self.pending_student:
            student = self.pending_student
            self.pending_student = None
            self.try_pair(student)


    def activate_fetcher_from_holding(self, fetcher_rfid, student):
        holding = self.holding[fetcher_rfid]

        self.active_fetcher = holding["fetcher"]
        self.fetcher_students = holding["students"]
        self.fetched_students = holding["fetched"]

        self.sync_fetched_from_global()

        self.check_and_mark_fetcher_completed()

        holding["widget"].hide()

        self.fetcher_panel.image.setPixmap(
            self.load_photo(self.active_fetcher.get("photo_path"))
        )
        self.fetcher_panel.name.setText(self.active_fetcher["Fetcher_name"])
        self.update_fetcher_student_list()

        self.try_pair(student)

        self.fetcher_timer.start(10000)

        
    def try_pair(self, student):

        # ---------- TEACHER OVERRIDE ----------
        if self.active_teacher:

            # Student already fetched ‚Üí same behavior
            if student["Student_id"] in self.fetched_students:

                # ‚úÖ SHOW STUDENT INFO AGAIN (SAME AS FETCHER FLOW)
                self.student_panel.image.setPixmap(
                    self.load_photo(student.get("photo_path"))
                )
                self.student_panel.name.setText(student["Student_name"])
                self.student_panel.info.setText(
                    f"ID: {student['Student_id']}\n"
                    f"Grade: {student['grade_lvl']}\n"
                    f"Teacher: {student['Teacher_name']}"
                )

                self.status.setText("STUDENT HAS ALREADY BEEN FETCHED")
                self.status.setStyleSheet(
                    "background:#f59e0b;color:black;padding:10px;"
                )
                return

            # ‚úÖ AUTHORIZATION RULE
            # Student.Teacher_name MUST match Teacher.Teacher_name
            if student["Teacher_name"] == self.active_teacher["Teacher_name"]:
                authorized = True
                status = "AUTHORIZED (TEACHER OVERRIDE)"
            else:
                authorized = False
                status = "DENIED"

            # Send result to Arduino
            self.serial.write(status)

            # Sound + record
            if authorized:
                self.sound_authorized.play()
                self.fetched_students.add(student["Student_id"])
                self.globally_fetched_students.add(student["Student_id"])

                self.save_history(
                    f"TEACHER ({self.active_teacher['Teacher_name']})",
                    student["Student_name"],
                    status
                )

                self.student_fetched_by[student["Student_id"]] = (
                    "TEACHER",
                    self.active_teacher
                )

                for rfid, h in self.holding.items():
                    if student["Student_id"] in h["student_ids"]:
                        h["fetched"].add(student["Student_id"])
                        self.update_holding_display(rfid)
                        break

                self.last_paired_type = "TEACHER"
                self.last_paired_data = self.active_teacher

                self.show_paired_by("TEACHER", self.active_teacher)
                QTimer.singleShot(8000, self.reset_student_after_pair)
                QTimer.singleShot(8000, self.reset_fetcher_panel_idle)
            else:
                self.sound_denied.play()
                
                self.save_history(
                f"TEACHER ({self.active_teacher['Teacher_name']})",
                student["Student_name"],
                status
            )


            # Status UI
            self.status.setText(status)
            self.status.setStyleSheet(
                f"background:{'#16a34a' if authorized else '#dc2626'};color:white;padding:10px;"
            )

            return  # üö® VERY IMPORTANT: STOP HERE

        # ==================================================
        # NORMAL FETCHER FLOW (UNCHANGED)
        # ==================================================

        if self.active_fetcher is None:
            return

        if student["Student_id"] in self.fetched_students:
            self.student_panel.image.setPixmap(
                self.load_photo(student.get("photo_path"))
            )
            self.student_panel.name.setText(student["Student_name"])
            self.student_panel.info.setText(
                f"ID: {student['Student_id']}\n"
                f"Grade: {student['grade_lvl']}\n"
                f"Teacher: {student['Teacher_name']}"
            )

            self.status.setText("STUDENT HAS ALREADY BEEN FETCHED")
            self.status.setStyleSheet(
                "background:#f59e0b;color:black;padding:10px;"
            )

            QTimer.singleShot(3000, self.reset_status_waiting_student)
            QTimer.singleShot(3000, self.safe_move_fetcher_to_holding)
            return

        self.cursor.execute("""
            SELECT * FROM registrations
            WHERE rfid=%s AND student_id=%s
        """, (
            self.active_fetcher["rfid"],
            student["Student_id"]
        ))

        authorized = self.cursor.fetchone() is not None
        status = "AUTHORIZED" if authorized else "DENIED"
        self.serial.write(status)

        if authorized:
            self.sound_authorized.play()
        else:
            self.sound_denied.play()

        self.student_panel.image.setPixmap(self.load_photo(student.get("photo_path")))
        self.student_panel.name.setText(student["Student_name"])
        self.student_panel.info.setText(
            f"ID: {student['Student_id']}\n"
            f"Grade: {student['grade_lvl']}\n"
            f"Teacher: {student['Teacher_name']}"
        )

        self.status.setText(status)
        self.status.setStyleSheet(
            f"background:{'#16a34a' if authorized else '#dc2626'};color:white;padding:10px;"
        )

        self.save_history(
            self.active_fetcher["Fetcher_name"],
            student["Student_name"],
            status
        )

        if authorized:
            self.fetched_students.add(student["Student_id"])
            self.globally_fetched_students.add(student["Student_id"])
            self.student_fetched_by[student["Student_id"]] = (
                "FETCHER",
                self.active_fetcher
            )
            self.show_paired_by("FETCHER", self.active_fetcher)
            QTimer.singleShot(4000, self.reset_student_after_pair)
            QTimer.singleShot(10000, self.safe_move_fetcher_to_holding)
            self.update_fetcher_student_list()
            self.update_holding_display(self.active_fetcher["rfid"])

            if len(self.fetched_students) == len(self.fetcher_students):
                self.completed_fetchers.add(self.active_fetcher["rfid"])
                self.remove_from_holding(self.active_fetcher["rfid"])
                QTimer.singleShot(3000, self.reset_all)
                return

            self.fetcher_timer.start(8000)

        self.student_display_timer.start(3000)



    # ---------------- HOLDING ----------------
    def move_fetcher_to_holding(self):

        if self.active_teacher:
            self.reset_teacher_mode()
            return
        
        if not self.active_fetcher:
            return

        rfid = self.active_fetcher["rfid"]

        if rfid in self.holding and self.active_fetcher is None:
            return

        if rfid in self.holding:
            self.return_fetcher_to_holding(rfid)
            self.reset_all()
            return

        # OUTER CARD
        box = QFrame()
        box.setStyleSheet(
            "background:#e5e7eb;border-radius:10px;padding:2px;"
        )

        # üîÅ HORIZONTAL LAYOUT
        h = QHBoxLayout(box)
        h.setSpacing(10)

        # LEFT: FETCHER PHOTO
        img = QLabel(alignment=Qt.AlignCenter)
        img.setPixmap(self.load_photo(self.active_fetcher.get("photo_path")))
        img.setFixedSize(100, 100)
        img.setScaledContents(True)
        h.addWidget(img)

        # RIGHT: NAME + STUDENT LIST (VERTICAL)
        v = QVBoxLayout()
        v.setSpacing(3)

        # FETCHER NAME
        name = QLabel(self.active_fetcher["Fetcher_name"])
        name.setFont(QFont("Segoe UI", 12, QFont.Bold))
        v.addWidget(name)

        # STUDENT LIST
        student_labels = []
        for s in self.fetcher_students:
            lbl = QLabel("‚Ä¢ " + s["Student_name"])
            lbl.setFont(QFont("Segoe UI", 10))
            lbl.setStyleSheet(
                "color:green;" if s["Student_id"] in self.fetched_students else "color:gray;"
            )
            v.addWidget(lbl)
            student_labels.append(lbl)

        h.addLayout(v)
        self.holding_layout.addWidget(box)

        # SAVE TO HOLDING QUEUE (LOGIC UNCHANGED)
        self.holding[rfid] = {
            "fetcher": self.active_fetcher,
            "students": self.fetcher_students,
            "student_ids": {s["Student_id"] for s in self.fetcher_students},
            "fetched": self.fetched_students,
            "widget": box,
            "labels": student_labels,
            "expires": datetime.now() + timedelta(hours=1)
        }

        self.reset_all()

    def cleanup_holding(self):
        now = datetime.now()
        for rfid in list(self.holding.keys()):
            if self.holding[rfid]["expires"] < now:
                self.remove_from_holding(rfid)

    def remove_from_holding(self, fetcher_rfid):
        if fetcher_rfid in self.holding:
            self.holding[fetcher_rfid]["widget"].deleteLater()
            del self.holding[fetcher_rfid]

    # ---------------- HELPERS ----------------
    def get_students(self, rfid):
        self.cursor.execute("""
            SELECT s.Student_id, s.Student_name
            FROM registrations r
            JOIN student s ON r.student_id = s.Student_id
            WHERE r.rfid=%s
        """, (rfid,))
        return self.cursor.fetchall()

    def update_fetcher_student_list(self):
        html = "<b>Students to fetch:</b><br>"
        for s in self.fetcher_students:
            color = "green" if s["Student_id"] in self.fetched_students else "gray"
            html += f"<span style='color:{color}; font-weight:bold'>‚Ä¢ {s['Student_name']}</span><br>"
        self.fetcher_panel.info.setText(html)

    def reset_status_waiting_student(self):
        if self.active_fetcher:
            self.status.setText("WAITING FOR STUDENT")
            self.status.setStyleSheet("background:#6b7280;color:white;padding:10px;")

    def reset_student_panel(self):
        self.student_panel.image.setPixmap(self.load_photo(None))
        self.student_panel.name.setText("WAITING...")
        self.student_panel.info.setText("")
        self.status.setText("WAITING FOR RFID...")
        self.status.setStyleSheet("background:#6b7280;color:white;padding:10px;")

    def reset_all(self):

        if self.replay_mode:
            return

        self.fetcher_panel.title_label.setText("FETCHER")
        self.fetcher_panel.name.setText("WAITING...")
        self.active_fetcher = None
        self.fetcher_students = []
        self.fetched_students = set()
        self.pending_student = None

        self.fetcher_panel.image.setPixmap(self.load_photo(None))
        self.fetcher_panel.name.setText("WAITING...")
        self.fetcher_panel.info.setText("")

        self.reset_student_panel()
        self.fetcher_timer.stop()

        self.status.setText("WAITING FOR RFID...")
        self.status.setStyleSheet("background:#6b7280;color:white;padding:10px;")

    def save_history(self, fetcher, student, status):
        with open(self.history_file, "a", newline="", encoding="utf-8") as f:
            csv.writer(f).writerow([
                datetime.now().strftime("%Y-%m-%d"),
                datetime.now().strftime("%H:%M:%S"),
                fetcher, student, status
            ])

    def update_clock(self):
        now = datetime.now()
        self.date_label.setText(now.strftime("%A, %B %d, %Y"))
        self.time_label.setText(now.strftime("%I:%M:%S %p"))

    def show_temp_status(self, text, bg="#f59e0b", fg="black", delay=3000):
        self.status.setText(text)
        self.status.setStyleSheet(
            f"background:{bg};color:{fg};padding:10px;"
        )
        QTimer.singleShot(delay, self.reset_status_waiting_rfid)

    def reset_status_waiting_rfid(self):
        self.status.setText("WAITING FOR RFID...")
        self.status.setStyleSheet(
            "background:#6b7280;color:white;padding:10px;"
        )
    def return_fetcher_to_holding(self, rfid):
        if rfid in self.holding:
            widget = self.holding[rfid].get("widget")
            if widget:
                widget.show()

    def closeEvent(self, event):
        if self.serial:
            self.serial.stop()
            self.serial.wait()
        event.accept()
    
    def safe_move_fetcher_to_holding(self):
        if self.active_fetcher:
            self.move_fetcher_to_holding()
    
    def update_holding_display(self, fetcher_rfid):
        if fetcher_rfid not in self.holding:
            return

        holding = self.holding[fetcher_rfid]
        for lbl, s in zip(holding["labels"], holding["students"]):
            lbl.setStyleSheet(
                "color:green;" if s["Student_id"] in holding["fetched"] else "color:gray;"
            )
    def reset_teacher_mode(self):
        self.active_teacher = None
        self.teacher_timer.stop()
        self.fetcher_panel.title_label.setText("FETCHER")
        self.reset_all()

    def show_paired_by(self, person_type, data):
        """
        person_type: 'FETCHER' or 'TEACHER'
        data: fetcher or teacher row
        """

        if person_type == "TEACHER":
            self.fetcher_panel.title_label.setText("TEACHER")
            self.fetcher_panel.name.setText(f"TEACHER ({data['Teacher_name']})")
            self.fetcher_panel.info.setText(
                f"Name: {data['Teacher_name']}\n"
                f"Grade: {data['Teacher_grade']}"
            )
            self.fetcher_panel.image.setPixmap(
                self.load_photo(data.get("photo_path"))
            )

        else:  # FETCHER
            self.fetcher_panel.title_label.setText("FETCHER")
            self.fetcher_panel.name.setText(data["Fetcher_name"])
            self.fetcher_panel.info.setText(
                f"Students fetched: {len(self.fetched_students)}"
            )
            self.fetcher_panel.image.setPixmap(
                self.load_photo(data.get("photo_path"))
            )
    
    def reset_student_after_pair(self):
        self.student_panel.image.setPixmap(self.load_photo(None))
        self.student_panel.name.setText("WAITING...")
        self.student_panel.info.setText("")

        self.status.setText("WAITING FOR RFID...")
        self.status.setStyleSheet(
        "background:#6b7280;color:white;padding:10px;"
        )

    def reset_fetcher_panel_idle(self):
        self.fetcher_panel.title_label.setText("FETCHER")
        self.fetcher_panel.image.setPixmap(self.load_photo(None))
        self.fetcher_panel.name.setText("WAITING...")
        self.fetcher_panel.info.setText("")

    def return_fetcher_to_holding_and_idle(self):
        # Return fetcher visually back to holding (NO recreation)
        self.return_existing_fetcher_to_holding()

        # Reset fetcher panel UI only
        self.reset_fetcher_panel_idle()

        # Final idle status
        self.status.setText("WAITING FOR RFID...")
        self.status.setStyleSheet(
            "background:#6b7280;color:white;padding:10px;"
        )

    def show_fetcher_from_holding_temporarily(self, student_id):
        """
        Find the fetcher in holding who already fetched this student,
        show them in ACTIVE for a few seconds, then return to holding.
        """
        for rfid, h in self.holding.items():
            if student_id in h["fetched"]:
                fetcher = h["fetcher"]

                # üîπ Temporarily restore active fetcher
                self.active_fetcher = fetcher
                self.fetcher_students = h["students"]
                self.fetched_students = h["fetched"]

                # üîë IMPORTANT: sync paired state
                self.last_paired_type = "FETCHER"
                self.last_paired_data = fetcher

                # üîπ Show fetcher in ACTIVE panel
                self.show_paired_by("FETCHER", fetcher)
                self.fetcher_panel.title_label.setText("FETCHER")
                self.update_fetcher_student_list()

                # Hide holding card while active
                h["widget"].hide()

                # üîí Lock UI for 4 seconds before returning
                QTimer.singleShot(4000, self.return_fetcher_to_holding_and_idle)

                return
        
    def return_existing_fetcher_to_holding(self):
       
        for rfid, h in self.holding.items():
            if h["fetcher"] == self.active_fetcher:
                widget = h.get("widget")
                if widget:
                    widget.show()
                break

        self.active_fetcher = None
        self.fetcher_students = []
        self.fetched_students = set()

    def end_replay_mode(self):
         # üîì unlock first
        self.replay_mode = False

        # Clear student panel
        self.student_panel.image.setPixmap(self.load_photo(None))
        self.student_panel.name.setText("WAITING...")
        self.student_panel.info.setText("")

        # Return fetcher to holding
        self.return_existing_fetcher_to_holding()

        # Reset fetcher UI
        self.reset_fetcher_panel_idle()

        # Final idle status
        self.status.setText("WAITING FOR RFID...")
        self.status.setStyleSheet(
            "background:#6b7280;color:white;padding:10px;"
        )

    def sync_fetched_from_global(self):
        """
        Ensure fetched_students reflects global fetched state
        (used when fetcher becomes active AFTER teacher override)
        """
        if not self.active_fetcher:
            return

        for s in self.fetcher_students:
            if s["Student_id"] in self.globally_fetched_students:
                self.fetched_students.add(s["Student_id"])
    
    def check_and_mark_fetcher_completed(self):
        """
        If all students of the active fetcher are fetched,
        mark the fetcher as completed and block future taps.
        """
        if not self.active_fetcher:
            return

        if len(self.fetcher_students) == 0:
            return

        if len(self.fetched_students) == len(self.fetcher_students):
            self.completed_fetchers.add(self.active_fetcher["rfid"])
    


# ---------------- RUN ----------------
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = RFIDTapping()
    window.show()
    sys.exit(app.exec_())


import sys, time, os, subprocess
from datetime import datetime

# PyQt5 Imports
from PyQt5.QtMultimedia import QSoundEffect
from PyQt5.QtCore import QUrl, Qt, QTimer
from PyQt5.QtGui import QPixmap, QFont
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QPushButton,
    QVBoxLayout, QHBoxLayout, QFrame, QSizePolicy
)

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(BASE_DIR)

from utils.database import db_connect
from serial_comms import SerialThread

# ---------------- PATHS ----------------
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DEFAULT_PHOTO = os.path.join(BASE_DIR, "assets", "default_photo.jfif")
SOUND_DIR = os.path.join(BASE_DIR, "sound effect")

AUTHORIZED_SOUND = os.path.join(SOUND_DIR, "authorized_sound.wav")
DENIED_SOUND = os.path.join(SOUND_DIR, "denied_sound.wav")

class RFIDTapping(QMainWindow):
    def __init__(self):
        def __init__(self):
            super().__init__()
            self.setWindowTitle("RFID Student Fetcher System")
            self.setGeometry(100, 100, 1300, 800)

        # --- 1. Database Connection ---
        try:
            self.db = db_connect()
            self.cursor = self.db.cursor(dictionary=True)
            print("Database Connected Successfully.")
        except Exception as e:
            print(f"Database Error: {e}")

        # --- 2. Serial Hardware Connection ---
        # We try COM3 first, then COM4 as a fallback. 
        # If both fail, we enter Offline Mode.
        self.serial = None
        for port in ["COM3", "COM4"]:
            try:
                self.serial = SerialThread(port=port, baud=9600)
                self.serial.uid_scanned.connect(self.process_rfid)
                self.serial.start()
                print(f"RFID Reader Connected on {port}.")
                break 
            except Exception:
                continue

        if not self.serial:
            print("System running in OFFLINE MODE (No RFID hardware detected).")

        # --- 3. State Variables ---
        self.active_fetcher = None
        self.active_teacher = None
        
        # --- 4. UI & Audio Setup ---
        self.init_ui()
        self.init_timers()
        self.init_audio()
        self.reset_all()

    def init_timers(self):
        # Timer to clear student display after a scan
        self.student_display_timer = QTimer(singleShot=True)
        self.student_display_timer.timeout.connect(self.reset_student_panel)

        # Timer for the digital clock
        self.clock_timer = QTimer()
        self.clock_timer.timeout.connect(self.update_clock)
        self.clock_timer.start(1000)

    def init_audio(self):
        self.sound_authorized = QSoundEffect()
        self.sound_authorized.setSource(QUrl.fromLocalFile(AUTHORIZED_SOUND))
        self.sound_authorized.setVolume(0.9)

        self.sound_denied = QSoundEffect()
        self.sound_denied.setSource(QUrl.fromLocalFile(DENIED_SOUND))
        self.sound_denied.setVolume(0.9)

    def init_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout(central)

        # --- LEFT SIDE: PANELS ---
        self.fetcher_panel = self.create_panel("FETCHER", "#1e3a8a")
        self.student_panel = self.create_panel("STUDENT", "#047857")

        left_side = QHBoxLayout()
        left_side.addWidget(self.fetcher_panel)
        left_side.addWidget(self.student_panel)

        # --- RIGHT SIDE: CONTROLS ---
        right_side = QVBoxLayout()

        self.title = QLabel("LIVE MONITORING", alignment=Qt.AlignCenter)
        self.title.setFont(QFont("Segoe UI", 18, QFont.Bold))
        self.title.setStyleSheet("background: #2563eb; color: white; padding: 12px; border-radius: 5px;")

        self.datetime_frame = QFrame()
        self.datetime_frame.setStyleSheet("background:#d4d4d8; border-radius:10px; padding:5px;")
        dt_layout = QVBoxLayout(self.datetime_frame)
        self.date_label = QLabel(alignment=Qt.AlignCenter)
        self.time_label = QLabel(alignment=Qt.AlignCenter)
        self.date_label.setFont(QFont("Segoe UI", 12))
        self.time_label.setFont(QFont("Segoe UI", 16, QFont.Bold))
        dt_layout.addWidget(self.date_label)
        dt_layout.addWidget(self.time_label)

        self.status = QLabel("WAITING FOR SCAN...", alignment=Qt.AlignCenter)
        self.status.setFont(QFont("Segoe UI", 14, QFont.Bold))
        self.status.setStyleSheet("background:#6b7280; color:white; padding:15px; border-radius: 5px;")

        self.spacer = QFrame()
        self.spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        right_side.addWidget(self.title)
        right_side.addWidget(self.datetime_frame)
        right_side.addWidget(self.status)
        right_side.addWidget(self.spacer)

        main_layout.addLayout(left_side, 2)
        main_layout.addLayout(right_side, 1)

    def create_panel(self, title, color):
        frame = QFrame()
        frame.setFrameShape(QFrame.StyledPanel)
        frame.setStyleSheet(f"background: #f8fafc; border: 2px solid {color}; border-radius: 15px;")
        
        layout = QVBoxLayout(frame)
        lbl = QLabel(title, alignment=Qt.AlignCenter)
        lbl.setFont(QFont("Segoe UI", 20, QFont.Bold))
        lbl.setStyleSheet(f"background:{color}; color:white; padding:10px; border-top-left-radius:10px; border-top-right-radius:10px;")
        
        img = QLabel(alignment=Qt.AlignCenter)
        img.setFixedSize(200, 200)
        img.setStyleSheet("border: 1px solid #cbd5e1; background: white;")
        
        name = QLabel("NO DATA", alignment=Qt.AlignCenter)
        name.setFont(QFont("Segoe UI", 16, QFont.Bold))
        
        info = QLabel("", alignment=Qt.AlignCenter)
        info.setFont(QFont("Segoe UI", 12))
        info.setStyleSheet("color: #475569;")

        layout.addWidget(lbl)
        layout.setAlignment(Qt.AlignCenter)
        layout.addWidget(img, 0, Qt.AlignCenter)
        layout.addWidget(name)
        layout.addWidget(info)
        
        frame.title_label, frame.image, frame.name, frame.info = lbl, img, name, info
        return frame

    def load_photo(self, path):
        pix = QPixmap(path) if path and os.path.exists(path) else QPixmap()
        if pix.isNull(): pix = QPixmap(DEFAULT_PHOTO)
        return pix.scaled(200, 200, Qt.KeepAspectRatio, Qt.SmoothTransformation)

    # ---------------- LOGIC ----------------

    def process_rfid(self, uid):
        """
        Main entry point for scans. 
        It prioritizes Fetchers/Teachers to 'open' a session.
        """
        # 1. Check if it's a Teacher (Override mode)
        # Using a direct cursor execution since db_manager isn't fully defined in your snippet
        self.cursor.execute("SELECT * FROM teacher WHERE rfid = %s", (uid,))
        teacher = self.cursor.fetchone()
        if teacher:
            self.active_teacher = teacher
            self.active_fetcher = None # Clear fetcher if teacher taps
            self.status.setText(f"TEACHER MODE: {teacher['Teacher_name']}")
            self.status.setStyleSheet("background: #7c3aed; color: white; padding: 15px;")
            self.sound_authorized.play()
            return

        # 2. Check if it's a Fetcher (Authorized Guardian)
        self.cursor.execute("SELECT * FROM fetcher WHERE rfid = %s", (uid,))
        fetcher = self.cursor.fetchone()
        if fetcher:
            self.active_fetcher = fetcher
            self.active_teacher = None # Clear teacher if fetcher taps
            self.update_fetcher_ui(fetcher)
            self.status.setText("FETCHER ACTIVE - SCAN STUDENT")
            self.status.setStyleSheet("background: #1e3a8a; color: white; padding: 15px;")
            self.sound_authorized.play()
            return

        # 3. Check if it's a Student
        self.cursor.execute("SELECT * FROM student WHERE student_rfid = %s", (uid,))
        student = self.cursor.fetchone()
        if student:
            self.handle_student_scanned(student)
            return
            
        # 4. Unknown Tag
        self.status.setText("UNKNOWN TAG")
        self.status.setStyleSheet("background: #4b5563; color: white; padding: 15px;")
        self.sound_denied.play()

    
    def save_history_log(self, student, authority_name):
        try:
            log_sql = """
                INSERT INTO history_log 
                (fetcher_name, student_name, student_id, grade, teacher, location, time_out)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """
            
            data = (
                authority_name,              # fetcher_name
                student['Student_name'],     # student_name
                student['Student_id'],       # student_id
                student['grade_lvl'],        # grade
                student['Teacher_name'],     # teacher
                "Main Gate",                 # location (Default)
                datetime.now()               # time_out
            )
            
            self.cursor.execute(log_sql, data)
            self.db.commit()
            print(f"Log Saved: {student['Student_name']} authorized.")
        except Exception as e:
            print(f"Logging Error: {e}")

    def handle_student_scanned(self, student):
        self.update_student_ui(student)
        authorized = False
        authority_name = "" # Track name for history log

        # Case A: Teacher is tapping (Universal access)
        if self.active_teacher:
            authorized = True
            authority_name = f"Teacher: {self.active_teacher['Teacher_name']}"
            log_msg = f"Teacher {self.active_teacher['Teacher_name']} fetched {student['Student_name']}"

        # Case B: Fetcher is tapping (Check registrations table)
        elif self.active_fetcher:
            authority_name = self.active_fetcher['Fetcher_name']
            check_sql = """
                SELECT * FROM registrations 
                WHERE rfid = %s AND student_id = %s AND status = 'Active'
            """
            self.cursor.execute(check_sql, (self.active_fetcher['rfid'], student['Student_id']))
            pairing = self.cursor.fetchone()
            
            if pairing:
                authorized = True
                log_msg = f"Fetcher {self.active_fetcher['Fetcher_name']} fetched {student['Student_name']}"
            else:
                log_msg = "UNAUTHORIZED PAIRING"

        # Case C: Student is tapping (Check registrations table)
        elif self.active_student:
            authority_name = "Self-Fetched"
            check_sql = """
                SELECT * FROM registrations 
                WHERE rfid = %s AND student_id = %s AND status = 'Active'
            """
            self.cursor.execute(check_sql, (self.active_student['rfid'], student['Student_id']))
            pairing = self.cursor.fetchone()
            
            if pairing:
                authorized = True
                log_msg = f"Student {self.active_student['Student_name']} fetched {student['Student_name']}"
            else:
                log_msg = "UNAUTHORIZED PAIRING"
        else:
            self.status.setText("TAP FETCHER FIRST")
            self.status.setStyleSheet("background: #f59e0b; color: white; padding: 15px;")
            self.sound_denied.play()
            return

        if authorized:
            self.status.setText(f"AUTHORIZED: {student['Student_name']}")
            self.status.setStyleSheet("background: #16a34a; color: white; padding: 15px;")
            self.sound_authorized.play()
            
            # --- SEND SIGNAL TO ARDUINO ---
            if self.serial: self.serial.write(b"A") 
            
            # --- NEW: SAVE TO YOUR history_log TABLE ---
            self.save_history_log(student, authority_name)
            
        else:
            self.status.setText("ACCESS DENIED")
            self.status.setStyleSheet("background: #dc2626; color: white; padding: 15px;")
            self.sound_denied.play()
            
            # --- SEND SIGNAL TO ARDUINO ---
            if self.serial: self.serial.write(b"D")

        self.student_display_timer.start(5000)

    def update_fetcher_ui(self, fetcher):
        self.fetcher_panel.name.setText(fetcher["Fetcher_name"])
        self.fetcher_panel.info.setText(f"Relation: {fetcher.get('Relation', 'Authorized Fetcher')}")
        # Add photo logic if you have fetcher photos
        
    def update_student_ui(self, student):
        self.student_panel.image.setPixmap(self.load_photo(student.get("photo_path")))
        self.student_panel.name.setText(student["Student_name"])
        self.student_panel.info.setText(f"Grade: {student['grade_lvl']}\nTeacher: {student['Teacher_name']}")

    def update_clock(self):
        now = datetime.now()
        self.date_label.setText(now.strftime("%A, %B %d, %Y"))
        self.time_label.setText(now.strftime("%I:%M:%S %p"))

    def reset_all(self):
        self.active_fetcher = None
        self.active_teacher = None
        self.fetcher_panel.name.setText("WAITING...")
        self.fetcher_panel.info.setText("")
        self.reset_student_panel()

    def reset_student_panel(self):
        self.student_panel.image.setPixmap(self.load_photo(None))
        self.student_panel.name.setText("WAITING...")
        self.student_panel.info.setText("")

    def closeEvent(self, event):
        self.serial.stop()
        self.serial.wait()
        event.accept()

    def show_temp_status(self, text, bg="#f59e0b", fg="black", delay=3000):
        self.status.setText(text)
        self.status.setStyleSheet(
            f"background:{bg};color:{fg};padding:10px;"
        )
        QTimer.singleShot(delay, self.reset_status_waiting_rfid)

    def reset_status_waiting_rfid(self):
        self.status.setText("WAITING FOR RFID...")
        self.status.setStyleSheet(
            "background:#6b7280;color:white;padding:10px;"
        )
        
    
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = RFIDTapping()
    window.show()
    sys.exit(app.exec_())


    import sys, time, os, subprocess
import serial
import serial.tools.list_ports
from datetime import datetime

# PyQt5 Imports
from PyQt5.QtMultimedia import QSoundEffect
from PyQt5.QtCore import QUrl, Qt, QTimer, QThread, pyqtSignal
from PyQt5.QtGui import QPixmap, QFont
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QPushButton,
    QVBoxLayout, QHBoxLayout, QFrame, QSizePolicy
)

# --- 1. Database & Path Setup ---
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(BASE_DIR)

try:
    from utils.database import db_connect
except ImportError:
    print("Warning: Could not find utils.database. Ensure your folder structure is correct.")

# ---------------- PATHS ----------------
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
DEFAULT_PHOTO = os.path.join(CURRENT_DIR, "assets", "default_photo.jfif")
SOUND_DIR = os.path.join(CURRENT_DIR, "sound effect")

AUTHORIZED_SOUND = os.path.join(SOUND_DIR, "authorized_sound.wav")
DENIED_SOUND = os.path.join(SOUND_DIR, "denied_sound.wav")

# ---------------- SERIAL THREAD CLASS ----------------
class SerialThread(QThread):
    uid_scanned = pyqtSignal(str)

    def __init__(self, port="COM4", baud=9600):
        super().__init__()
        self.port = port
        self.baud = baud
        self.ser = None
        self._is_running = True

    def run(self):
        """Main loop that listens for serial data."""
        try:
            # Check if the port is available first
            available_ports = [p.device for p in serial.tools.list_ports.comports()]
            if self.port not in available_ports:
                print(f"Warning: Serial port {self.port} not found. Available: {available_ports}")
            
            self.ser = serial.Serial(self.port, self.baud, timeout=1)
            
            # Arduino resets when serial opens; wait 2 seconds for it to boot up
            time.sleep(2) 
            
            while self._is_running:
                if self.ser and self.ser.is_open and self.ser.in_waiting:
                    try:
                        # Read raw data, decode, and strip whitespace/newlines
                        raw_data = self.ser.readline().decode(errors="ignore").strip()
                        
                        if raw_data:
                            # Extracts only the part after the last colon
                            clean_uid = raw_data.split(":")[-1].strip()
                            
                            if clean_uid:
                                self.uid_scanned.emit(clean_uid)
                    except Exception as e:
                        print(f"Data read error: {e}")
                
                # Small sleep to prevent high CPU usage
                self.msleep(50)

        except Exception as e:
            print(f"Serial connection error on {self.port}: {e}")
        finally:
            self.stop()

    def write(self, message):
        """Sends a string command to the Arduino (e.g., 'A' or 'D')."""
        if self.ser and self.ser.is_open:
            try:
                formatted_msg = (message + "\n").encode()
                self.ser.write(formatted_msg)
            except Exception as e:
                print(f"Serial write error: {e}")

    def stop(self):
        """Safely shuts down the thread and closes the port."""
        self._is_running = False
        if self.ser and self.ser.is_open:
            try:
                self.ser.close()
            except:
                pass
        self.quit()

# ---------------- MAIN WINDOW CLASS ----------------
class RFIDTapping(QMainWindow):
    def __init__(self):
        super().__init__() # FIXED: Removed duplicate nested __init__
        self.setWindowTitle("RFID Student Fetcher System")
        self.setGeometry(100, 100, 1300, 800)

        # --- 1. Database Connection ---
        try:
            self.db = db_connect()
            self.cursor = self.db.cursor(dictionary=True)
            print("Database Connected Successfully.")
        except Exception as e:
            print(f"Database Error: {e}")

        # --- 2. Serial Hardware Connection ---
        self.serial = None
        for port in ["COM3", "COM4", "COM5"]:
            try:
                self.serial = SerialThread(port=port, baud=9600)
                self.serial.uid_scanned.connect(self.process_rfid)
                self.serial.start()
                print(f"RFID Reader Connected on {port}.")
                break 
            except Exception:
                continue

        if not self.serial:
            print("System running in OFFLINE MODE (No RFID hardware detected).")

        # --- 3. State Variables ---
        self.active_fetcher = None
        self.active_teacher = None
        
        # --- 4. UI & Audio Setup ---
        self.init_ui()
        self.init_timers()
        self.init_audio()
        self.reset_all()

    def init_timers(self):
        self.student_display_timer = QTimer(singleShot=True)
        self.student_display_timer.timeout.connect(self.reset_student_panel)

        self.clock_timer = QTimer()
        self.clock_timer.timeout.connect(self.update_clock)
        self.clock_timer.start(1000)

    def init_audio(self):
        self.sound_authorized = QSoundEffect()
        self.sound_authorized.setSource(QUrl.fromLocalFile(AUTHORIZED_SOUND))
        self.sound_authorized.setVolume(0.9)

        self.sound_denied = QSoundEffect()
        self.sound_denied.setSource(QUrl.fromLocalFile(DENIED_SOUND))
        self.sound_denied.setVolume(0.9)

    def init_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout(central)

        # --- LEFT SIDE: PANELS ---
        self.fetcher_panel = self.create_panel("FETCHER", "#1e3a8a")
        self.student_panel = self.create_panel("STUDENT", "#047857")

        left_side = QHBoxLayout()
        left_side.addWidget(self.fetcher_panel)
        left_side.addWidget(self.student_panel)

        # --- RIGHT SIDE: CONTROLS ---
        right_side = QVBoxLayout()

        self.title = QLabel("LIVE MONITORING", alignment=Qt.AlignCenter)
        self.title.setFont(QFont("Segoe UI", 18, QFont.Bold))
        self.title.setStyleSheet("background: #2563eb; color: white; padding: 12px; border-radius: 5px;")

        self.datetime_frame = QFrame()
        self.datetime_frame.setStyleSheet("background:#d4d4d8; border-radius:10px; padding:5px;")
        dt_layout = QVBoxLayout(self.datetime_frame)
        self.date_label = QLabel(alignment=Qt.AlignCenter)
        self.time_label = QLabel(alignment=Qt.AlignCenter)
        self.date_label.setFont(QFont("Segoe UI", 12))
        self.time_label.setFont(QFont("Segoe UI", 16, QFont.Bold))
        dt_layout.addWidget(self.date_label)
        dt_layout.addWidget(self.time_label)

        self.status = QLabel("WAITING FOR SCAN...", alignment=Qt.AlignCenter)
        self.status.setFont(QFont("Segoe UI", 14, QFont.Bold))
        self.status.setStyleSheet("background:#6b7280; color:white; padding:15px; border-radius: 5px;")

        self.spacer = QFrame()
        self.spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        right_side.addWidget(self.title)
        right_side.addWidget(self.datetime_frame)
        right_side.addWidget(self.status)
        right_side.addWidget(self.spacer)

        main_layout.addLayout(left_side, 2)
        main_layout.addLayout(right_side, 1)

    def create_panel(self, title, color):
        frame = QFrame()
        frame.setStyleSheet(f"background: #f8fafc; border: 2px solid {color}; border-radius: 15px;")
        
        layout = QVBoxLayout(frame)
        lbl = QLabel(title, alignment=Qt.AlignCenter)
        lbl.setFont(QFont("Segoe UI", 20, QFont.Bold))
        lbl.setStyleSheet(f"background:{color}; color:white; padding:10px; border-top-left-radius:10px; border-top-right-radius:10px;")
        
        img = QLabel(alignment=Qt.AlignCenter)
        img.setFixedSize(200, 200)
        img.setStyleSheet("border: 1px solid #cbd5e1; background: white;")
        
        name = QLabel("NO DATA", alignment=Qt.AlignCenter)
        name.setFont(QFont("Segoe UI", 16, QFont.Bold))
        
        info = QLabel("", alignment=Qt.AlignCenter)
        info.setFont(QFont("Segoe UI", 12))
        info.setStyleSheet("color: #475569;")

        layout.addWidget(lbl)
        layout.setAlignment(Qt.AlignCenter)
        layout.addWidget(img, 0, Qt.AlignCenter)
        layout.addWidget(name)
        layout.addWidget(info)
        
        frame.image, frame.name, frame.info = img, name, info
        return frame

    def load_photo(self, path):
        pix = QPixmap(path) if path and os.path.exists(path) else QPixmap()
        if pix.isNull(): pix = QPixmap(DEFAULT_PHOTO)
        return pix.scaled(200, 200, Qt.KeepAspectRatio, Qt.SmoothTransformation)

    def process_rfid(self, uid):
        # 1. Check if Teacher
        self.cursor.execute("SELECT * FROM teacher WHERE rfid = %s", (uid,))
        teacher = self.cursor.fetchone()
        if teacher:
            self.active_teacher = teacher
            self.active_fetcher = None 
            self.status.setText(f"TEACHER MODE: {teacher['Teacher_name']}")
            self.status.setStyleSheet("background: #7c3aed; color: white; padding: 15px;")
            self.sound_authorized.play()
            return

        # 2. Check if Fetcher
        self.cursor.execute("SELECT * FROM fetcher WHERE rfid = %s", (uid,))
        fetcher = self.cursor.fetchone()
        if fetcher:
            self.active_fetcher = fetcher
            self.active_teacher = None
            self.update_fetcher_ui(fetcher)
            self.status.setText("FETCHER ACTIVE - SCAN STUDENT")
            self.status.setStyleSheet("background: #1e3a8a; color: white; padding: 15px;")
            self.sound_authorized.play()
            return

        # 3. Check if Student
        self.cursor.execute("SELECT * FROM student WHERE student_rfid = %s", (uid,))
        student = self.cursor.fetchone()
        if student:
            self.handle_student_scanned(student)
            return
            
        self.status.setText("UNKNOWN TAG")
        self.status.setStyleSheet("background: #4b5563; color: white; padding: 15px;")
        self.sound_denied.play()

    def save_history_log(self, student, authority_name):
        """Saves current log and automatically clears logs older than 7 days."""
        try:
            # Insert log
            log_sql = """
                INSERT INTO history_log 
                (fetcher_name, student_name, student_id, grade, teacher, location, time_out)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """
            data = (
                authority_name, 
                student['Student_name'], 
                student['Student_id'], 
                student['grade_lvl'], 
                student['Teacher_name'], 
                "Main Gate", 
                datetime.now()
            )
            self.cursor.execute(log_sql, data)

            # --- AUTO-CLEANUP: Keep only last 7 days ---
            cleanup_sql = "DELETE FROM history_log WHERE time_out < NOW() - INTERVAL 7 DAY"
            self.cursor.execute(cleanup_sql)

            self.db.commit()
            print(f"Log Saved: {student['Student_name']}. Old logs cleared.")
        except Exception as e:
            print(f"Logging Error: {e}")

    def handle_student_scanned(self, student):
        self.update_student_ui(student)
        authorized = False
        authority_name = ""

        if self.active_teacher:
            authorized = True
            authority_name = f"Teacher: {self.active_teacher['Teacher_name']}"
        elif self.active_fetcher:
            authority_name = self.active_fetcher['Fetcher_name']
            check_sql = "SELECT * FROM registrations WHERE rfid = %s AND student_id = %s AND status = 'Active'"
            self.cursor.execute(check_sql, (self.active_fetcher['rfid'], student['Student_id']))
            if self.cursor.fetchone():
                authorized = True

        if authorized:
            self.status.setText(f"AUTHORIZED: {student['Student_name']}")
            self.status.setStyleSheet("background: #16a34a; color: white; padding: 15px;")
            self.sound_authorized.play()
            if self.serial: self.serial.write("A") 
            self.save_history_log(student, authority_name)
        else:
            self.status.setText("ACCESS DENIED")
            self.status.setStyleSheet("background: #dc2626; color: white; padding: 15px;")
            self.sound_denied.play()
            if self.serial: self.serial.write("D")

        self.student_display_timer.start(5000)

    def update_fetcher_ui(self, fetcher):
        self.fetcher_panel.name.setText(fetcher["Fetcher_name"])
        self.fetcher_panel.info.setText(f"Relation: {fetcher.get('Relation', 'Authorized Fetcher')}")
        
    def update_student_ui(self, student):
        self.student_panel.image.setPixmap(self.load_photo(student.get("photo_path")))
        self.student_panel.name.setText(student["Student_name"])
        self.student_panel.info.setText(f"Grade: {student['grade_lvl']}\nTeacher: {student['Teacher_name']}")

    def update_clock(self):
        now = datetime.now()
        self.date_label.setText(now.strftime("%A, %B %d, %Y"))
        self.time_label.setText(now.strftime("%I:%M:%S %p"))

    def reset_all(self):
        self.active_fetcher = None
        self.active_teacher = None
        self.fetcher_panel.name.setText("WAITING...")
        self.fetcher_panel.info.setText("")
        self.reset_student_panel()

    def reset_student_panel(self):
        self.student_panel.image.setPixmap(self.load_photo(None))
        self.student_panel.name.setText("WAITING...")
        self.student_panel.info.setText("")

    def closeEvent(self, event):
        if self.serial:
            self.serial.stop()
            self.serial.wait()
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = RFIDTapping()
    window.show()
    sys.exit(app.exec_())


    def start_serial_listener(self):
        def listen():
            # Auto-detect COM port
            ports = list(serial.tools.list_ports.comports())
            target_port = next((p.device for p in ports if any(x in p.description for x in ["USB", "CH340", "Arduino"])), "COM3")
            
            try:
                self.ser = serial.Serial(target_port, 9600, timeout=0.1)
                print(f"Connected to Arduino on {target_port}")
            except Exception as e:
                print(f"Serial Error: {e}")
                return

            while self.running:
                try:
                    if self.ser and self.ser.is_open and self.ser.in_waiting:
                        # Change this line inside start_serial_listener -> listen()
                        line = self.ser.readline().decode('utf-8', errors='ignore').strip().replace('\r', '')
                        if line:
                            # Clean the UID string (removes "UID Tag: " prefix if present)
                            uid = line.split(":")[-1].strip() if ":" in line else line
                            self.after(0, self.dispatch_rfid, uid)
                except:
                    break
            
            if self.ser: self.ser.close()

        thread = threading.Thread(target=listen, daemon=True)
        thread.start()